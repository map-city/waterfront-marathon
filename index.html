<!DOCTYPE html>
<html>

<head>
	<meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no" />
	<script src="https://unpkg.com/maplibre-gl@latest/dist/maplibre-gl.js"></script>
	<link href="https://unpkg.com/maplibre-gl@latest/dist/maplibre-gl.css" rel="stylesheet" />
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">
	<link rel="stylesheet" href="style.css">
</head>

<body>
	<div id="map"></div>
	<div id="time-container">
		<div id="start-time" class="info-box"></div>
		<div id="finish-wrapper" >
			<div id="finish-time" class="info-box"></div>
			<button id="time-minus">-</button>
			<button id="time-plus">+</button>
		</div>
  </div>
	</div>
	<script>
		const timeInrecment = 5 * 60 * 1000;
		const raceDistance = 42200;
		const raceStart = new Date("2025-10-19T08:00:00-04:00"); // Toronto time (EDT)
		let raceFinish = new Date("2025-10-19T11:30:00-04:00");
		let raceDuration = raceFinish - raceStart; // in ms

		var map = new maplibregl.Map({
			container: 'map',
			style: 'maplibre.json',
			center: [-79.3868, 43.6505],
			zoom: 15,
            minZoom: 12,
			maxZoom: 18,
			bearing: -14,
			pitch: 0,
			pixelRatio: 1,
			hash: true
		});

		let cheerPointsData = null;

		map.on('load', async () => {
			map.addSource('route', {
				'type': 'geojson',
				'data': 'data/route.geojson'
			});

			// Load cheer points and store the data
			const response = await fetch('data/cheer_points.geojson');
			cheerPointsData = await response.json();

			map.addSource('cheer_points', {
				'type': 'geojson',
				'data': cheerPointsData
			});

            map.addLayer({
                "id": "route",
                "source": "route",
                "type": "line",
                "paint": {
					"line-color": "hsl(337, 100%, 45%)",
					"line-width": 3
				}
            });

			map.addLayer({
                "id": "cheer_points",
                "source": "cheer_points",
                "type": "circle",
                "paint": {
					"circle-color": "white",
					"circle-radius": 12,
					"circle-stroke-color": "hsl(337, 100%, 45%)",
        			"circle-stroke-width": 4
				}
            });
			
			map.addLayer({
				"id": "cheer_points_etas",
				"source": "cheer_points",
				"type": "symbol",
				"layout": {
					"text-field": ["get", "eta"],
					"text-size": 11,
					"text-font": [ "montserrat-semibold" ],
					"text-offset": [0, 2.2],
					"text-anchor": "center",
					"text-allow-overlap": false,
					"text-ignore-placement": false
				},
				"paint": {
					"text-color": "hsl(247, 100%, 45%)", 
					"text-halo-color": "white",
					"text-halo-width": 2
				}
			});

			map.addLayer({
				"id": "cheer_points_labels",
				"source": "cheer_points",
				"type": "symbol",
				"layout": {
					"text-field": ["get", "name"],
					"text-size": 11,
					"text-font": [ "montserrat-semibold" ],
					"text-offset": [0, 0],
					"text-anchor": "center",
					"text-allow-overlap": true,
					"text-ignore-placement": false
				},
				"paint": {
					"text-color": "hsl(337, 100%, 0%)",
					"text-halo-color": "white",
            		"text-halo-width": 2
				}
			});

			updateAllETAs();
        });

		// Format time as h:mm AM/PM
		const formatTime = (date) => {
			return date.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit', hour12: true});
		};

		// Helper to get distances as array from feature object
		// MapLibre has a weird behaviour that converts array -> string
		const getDistancesArray = (dist_m) => {
			if (Array.isArray(dist_m)) return dist_m;
			if (typeof dist_m === 'string' && dist_m.startsWith('[')) {
				try {
					return JSON.parse(dist_m);
				} catch (e) {
					return [0];
				}
			}
			return [parseFloat(dist_m) || 0];
		};

		const calculateETAString = (feature) => {
			const { name, dist_m } = feature.properties;
			const distances = getDistancesArray(dist_m);
			
			const etas = distances.map(distance => {
				const progress = Math.min(distance / raceDistance, 1);
				const arrival = new Date(raceStart.getTime() + raceDuration * progress);
				return arrival;
			});			
			
			etas.sort((a, b) => a - b);			
			const formattedEtas = etas.map(eta => formatTime(eta));
			
			return etaText = formattedEtas.length === 1 
				? `${formattedEtas[0]}` 
				: `${formattedEtas.join(', ')}`;
		};

		// Update all ETA labels
		const updateAllETAs = () => {
			if (!cheerPointsData) return;
			
			// Update the data with new ETAs
			cheerPointsData.features.forEach(feature => {
				feature.properties.eta = calculateETAString(feature);
			});
			
			// Update the source data
			map.getSource('cheer_points').setData(cheerPointsData);
		};

		// Populate the time boxes boxes
		document.addEventListener("DOMContentLoaded", () => {
			document.getElementById("start-time").textContent = `Start: ${formatTime(raceStart)}`;
			document.getElementById("finish-time").textContent = `Finish: ${formatTime(raceFinish)}`;
		});

		// Update finish time and recompute raceDuration
		const updateFinishTime = () => {
			raceDuration = raceFinish - raceStart;
			document.getElementById("finish-time").textContent = `Finish: ${formatTime(raceFinish)}`;
			updateAllETAs();
		};

		document.getElementById("time-minus").addEventListener("click", () => {
			raceFinish = new Date(raceFinish.getTime() - timeInrecment);
			updateFinishTime();
		});

		document.getElementById("time-plus").addEventListener("click", () => {
			raceFinish = new Date(raceFinish.getTime() + timeInrecment);
			updateFinishTime();
		});

	</script>
</body>

</html>