<!DOCTYPE html>
<html>

<head>
	<meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no" />
	<script src="https://unpkg.com/maplibre-gl@latest/dist/maplibre-gl.js"></script>
	<link href="https://unpkg.com/maplibre-gl@latest/dist/maplibre-gl.css" rel="stylesheet" />
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">
	<link rel="stylesheet" href="style.css">
</head>

<body>
	<div id="map"></div>
	<div id="time-container">
		<div id="start-time" class="info-box"></div>
		<div id="finish-wrapper" >
			<div id="finish-time" class="info-box"></div>
			<button id="time-minus">-</button>
			<button id="time-plus">+</button>
		</div>
  </div>
	</div>
	<script>
		const timeInrecment = 5 * 60 * 1000;
		const raceDistance = 42200;
		const raceStart = new Date("2025-10-19T08:00:00-04:00"); // Toronto time (EDT)
		let raceFinish = new Date("2025-10-19T11:30:00-04:00");
		let raceDuration = raceFinish - raceStart; // in ms

		var map = new maplibregl.Map({
			container: 'map',
			style: 'maplibre.json',
			center: [-79.3794, 43.6462],
			zoom: 12.5,
            minZoom: 11,
			maxZoom: 18,
			bearing: -14,
			pitch: 0,
			pixelRatio: 1,
			hash: true
		});

		map.on('load', async () => {
			map.addSource('route', {
				'type': 'geojson',
				'data': 'data/route.geojson'
			});

			map.addSource('cheer_points', {
				'type': 'geojson',
				'data': 'data/cheer_points.geojson'
			});

            map.addLayer({
                "id": "route",
                "source": "route",
                "type": "line",
                "paint": {
					"line-color": "hsl(337, 100%, 45%)",
					"line-width": 3
				}
            });

			map.addLayer({
                "id": "cheer_points",
                "source": "cheer_points",
                "type": "circle",
                "paint": {
					"circle-color": "hsl(337, 100%, 45%)",
					"circle-radius": 8
				}
            });
        });

		// Format time as h:mm AM/PM
		const formatTime = (date) => {
			return date.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' });
		};

		// Populate the time boxes boxes
		document.addEventListener("DOMContentLoaded", () => {
			document.getElementById("start-time").textContent = `Start: ${formatTime(raceStart)}`;
			document.getElementById("finish-time").textContent = `Finish: ${formatTime(raceFinish)}`;
		});

		// Update finish time and recompute raceDuration
		const updateFinishTime = () => {
			raceDuration = raceFinish - raceStart;
			document.getElementById("finish-time").textContent = `Finish: ${formatTime(raceFinish)}`;
		};

		document.getElementById("time-minus").addEventListener("click", () => {
			raceFinish = new Date(raceFinish.getTime() - timeInrecment);
			updateFinishTime();
		});

		document.getElementById("time-plus").addEventListener("click", () => {
			raceFinish = new Date(raceFinish.getTime() + timeInrecment);
			updateFinishTime();
		});

		// Helper to get distances as array from feature object
		// MapLibre has a weird behaviour that converts array -> string
		const getDistancesArray = (dist_m) => {
			if (Array.isArray(dist_m)) return dist_m;
			if (typeof dist_m === 'string' && dist_m.startsWith('[')) {
				try {
					return JSON.parse(dist_m);
				} catch (e) {
					return [0];
				}
			}
			return [parseFloat(dist_m) || 0];
		};

		// Popup content generator
		const createPopupContent = (feature) => {
			const { name, dist_m } = feature.properties;
			const distances = getDistancesArray(dist_m);
			
			const etas = distances.map(distance => {
				const progress = Math.min(distance / raceDistance, 1);
				const arrival = new Date(raceStart.getTime() + raceDuration * progress);
				return arrival;
			});			
			
			etas.sort((a, b) => a - b);			
			const formattedEtas = etas.map(eta => formatTime(eta));
			
			let etaText = formattedEtas.length === 1 
				? `ETA: ${formattedEtas[0]}` 
				: `ETA: ${formattedEtas.join(', ')}`;
			
			return `<strong>${name}</strong><br>${etaText}`;
		};

		// Reusable hover popup
		const hoverPopup = new maplibregl.Popup({
			closeButton: false,
			closeOnClick: false
		});

		// Only one clickPopup at a time
    	let clickPopup = null;

		// Generic popup setter
		const showPopup = (popup, feature) => {
			popup.setLngLat(feature.geometry.coordinates.slice())
				.setHTML(createPopupContent(feature))
				.addTo(map);
		};

		// --- Hover events ---
		map.on('mouseenter', 'cheer_points', (e) => {
			map.getCanvas().style.cursor = 'pointer';
			showPopup(hoverPopup, e.features[0]);
		});

		map.on('mouseleave', 'cheer_points', () => {
			map.getCanvas().style.cursor = '';
			hoverPopup.remove();
		});

		// --- Click events ---
		map.on('click', 'cheer_points', (e) => {
			if (clickPopup) clickPopup.remove(); // close previous
			clickPopup = new maplibregl.Popup({ closeButton: false });
			showPopup(clickPopup, e.features[0]);
		});

		// Close click popup when clicking outside cheer points
		map.on('click', (e) => {
			const features = map.queryRenderedFeatures(e.point, {
				layers: ['cheer_points']
			});

			if (!features.length && clickPopup) {
				clickPopup.remove();
				clickPopup = null;
			}
		});

	</script>
</body>

</html>